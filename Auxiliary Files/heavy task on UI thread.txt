Добавление 20К элементов в ObservableCollection, к которой прибинжено отображение на экране

1) Добавление по 1 элементу непосредственно в UI потоке - 3:54 и все замерзает на это время

2 - не имеет смысла - 4 делает все что надо
2) Запускаем другой поток, который через GetDispatcher().Invoke отдает элементы в UI поток 
т.е.
var unused = await Task.Factory.StartNew(() => _renderingApplier.ToEmptyGraphFromAnotherThread(renderingResult));
а там 
_dispatcherProvider.GetDispatcher().Invoke(() => { _graphReadModel.Data.Nodes.Add(nodeVm); });

2.1) по одному элементу - 4:00  и все замерзает
2.2) по одному элементу и после каждого sleep 10 ms - 11 минут и progressBar движется гладко
2.3) по одному элементу и после каждого sleep 2 ms - 9:43 и progressBar движется с едва заметными рывками

2.4) пакетами по 20 и после пакета sleep 2 ms - 2:30 progressBar движется с заметными рывками
2.5) пакетами по 50 и после пакета sleep 2 ms - 2:13 progressBar движется еще хуже, но движение постоянно видно

3 - не имеет смысла - 4 делает то же самое , но проще
3) Добавление элементов из UI потока, но с вызовами sleep на другом потоке и await этих вызовов на UI потоке -
	UI поток не морозится
	
3.1) по одному элементу и после каждого sleep 10 ms - 10:50 движется с едва заметными рывками

3.5) пакетами по 50 и после пакета sleep 10 ms - 2:17 progressBar движется рывками, но движение постоянно видно
3.5) пакетами по 50 и после пакета sleep 2 ms - 2:11 progressBar движется рывками, но движение постоянно видно

4) Task.Delay в UI потоке для размораживания UI потока
4.5) пакетами по 50 и после пакета delay 2 ms - 2:13 progressBar движется рывками, но движение постоянно видно