- если отключить трассу при выкинутых FreePorts - не перерисовывает дерево

- сообщения от непрописанных трасс показывать? (у меня после чистки БД возникли)

- Измерение Reflect - если есть прямая связь клиент -рту 
- Измерение Client -все через сервер - запрос допустимых параметров  - установка их - измерние - получение рефлектограммы - показ ее в рефлекте
- Точное измерение вне очереди - все команды через сервер - остановить мониторинг рту (если идет) - 
		померять порт с точной базовой - прислать измерение по стандартным каналам - 
		принудительно открыть окно TraceState в клиенте - вернуть мониторинг (если был)


 - Посылка команды на сервер иногда притормаживает - и решив что не кликнул я нажимаю повторно - получается "задвоенная команда" 
 (например присоединения трассы к порту) - при приходе двух событий прога кидает эксепшен (или задваивает обработку)
	толи все команды проверить и отключать кнопку ОК пока незавершена обработка
	но лучше чтобы C2DWcfManager не позволял подать вторую команду пока первая не обработана




	1. Equipment хранить прямо в узлах
	2. Для трасс хранить список волокон
	3. blahblahViewModel должна использовать ReadModel а не GraphReadModel, как и все остальные формы
	6.


Результат мониторинга приходит на сервер (MSMQ):
	если не сущ RTU игнорим
	сохраняем сорку в БД, независимо от того ивент или нет парсим сорку  - GetAccidents(sorData, true)
	формируем команду AddMeasurement у которой внутри и поля Measurement(), список Accidents и 
	отдаем Aggregate который проверяет существование трассы, 
	если есть, то 
		WriteModel применяет событие MeasurementAdded к своим данным (создавая узлы в месте аварий, изменяя состояние волокон и трасс)
		но сохраняет в БД ивентсоурсинга именно событие MeasurementAdded
    клиент вытягивает событие MeasurementAdded и применяет его к своим моделям
	а) если событие произошло когда клиент открыт:
		MeasurementAdded применяется отдельно к ReadModel и GraphReadModel (и еще кучке моделей)
	б) если событие произошло ранее, клиент открывается сейчас:
		- все события из кэша+БД применяются к моделям кроме GraphReadModel (т.к. очень медленная)
		- уже сформированная ReadModel транслируется в GraphReadModel 
			(что позволяет сэкономить если с каким-то объектом производилось несколько действий,
			то отрисовываем на карте только конечный результат)
		- далее работает по варианту a)

   Отсоединение аварийной трассы (event TraceDetached) 
    - изменение состояния самой трассы на NotJoined (синяя) 
	- очистка порта
	- удаление узлов-аварий данной трассы (если были)
	- для каждого участка трассы 
		- изменение состояния трассы в массиве состояний трасс проходящих в участке на NotJoined (синяя) 
		- удаление трассы из массива превышеных затуханий (если были)

   Присоединение трассы (event TraceAttached)
   - в момент подачи команды 
	- находим последнее измерение (event MeasurementAdded) по данной трассе и в команду (а она транслируется в событие)
		сохраняем состояние и аварии (если были) трассы по состоянию на последнее измерение:

  - когда приходит событие исходя из этих данных делаем:
		- изменение состояния самой трассы 
		- назначение порта
		- для каждого участка трассы 
			- изменение состояния трассы в массиве состояний трасс проходящих в участке 
    - применяем Accidents из MeasurementAdded:
		- добавление узлов-аварий данной трассы (если надо)
		- добавление трассы в массив превышеных затуханий (если надо)
	- отправка базовых на RTU

